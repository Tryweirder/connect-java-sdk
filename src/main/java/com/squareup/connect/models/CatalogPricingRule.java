/*
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * OpenAPI spec version: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.squareup.connect.models;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.squareup.connect.models.Money;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;

/**
 * Defines how prices are modified or set for items that match the pricing rule during the active time period.
 */
@ApiModel(description = "Defines how prices are modified or set for items that match the pricing rule during the active time period.")

public class CatalogPricingRule {
  @JsonProperty("name")
  private String name = null;

  @JsonProperty("time_period_ids")
  private List<String> timePeriodIds = new ArrayList<String>();

  @JsonProperty("total_price_money")
  private Money totalPriceMoney = null;

  @JsonProperty("item_price_money")
  private Money itemPriceMoney = null;

  @JsonProperty("discount_id")
  private String discountId = null;

  @JsonProperty("match_products_id")
  private String matchProductsId = null;

  @JsonProperty("apply_products_id")
  private String applyProductsId = null;

  /**
   * Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values
   */
  public enum StackableEnum {
    UNKNOWN("UNKNOWN"),
    
    BASE("BASE"),
    
    STACKABLE("STACKABLE"),
    
    EXCLUSIVE("EXCLUSIVE");

    private String value;

    StackableEnum(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StackableEnum fromValue(String text) {
      for (StackableEnum b : StackableEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
  }

  @JsonProperty("stackable")
  private StackableEnum stackable = null;

  @JsonProperty("exclude_products_id")
  private String excludeProductsId = null;

  @JsonProperty("valid_from_date")
  private String validFromDate = null;

  @JsonProperty("valid_from_local_time")
  private String validFromLocalTime = null;

  @JsonProperty("valid_until_date")
  private String validUntilDate = null;

  @JsonProperty("valid_until_local_time")
  private String validUntilLocalTime = null;

  public CatalogPricingRule name(String name) {
    this.name = name;
    return this;
  }

   /**
   * User-defined name for the pricing rule. For example, \"Buy one get one free\" or \"10% off\".
   * @return name
  **/
  @ApiModelProperty(value = "User-defined name for the pricing rule. For example, \"Buy one get one free\" or \"10% off\".")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public CatalogPricingRule timePeriodIds(List<String> timePeriodIds) {
    this.timePeriodIds = timePeriodIds;
    return this;
  }

  public CatalogPricingRule addTimePeriodIdsItem(String timePeriodIdsItem) {
    this.timePeriodIds.add(timePeriodIdsItem);
    return this;
  }

   /**
   * Unique ID for the [CatalogTimePeriod](#type-catalogtimeperiod)s when this pricing rule is in effect. If left unset, the pricing rule is always in effect.
   * @return timePeriodIds
  **/
  @ApiModelProperty(value = "Unique ID for the [CatalogTimePeriod](#type-catalogtimeperiod)s when this pricing rule is in effect. If left unset, the pricing rule is always in effect.")
  public List<String> getTimePeriodIds() {
    return timePeriodIds;
  }

  public void setTimePeriodIds(List<String> timePeriodIds) {
    this.timePeriodIds = timePeriodIds;
  }

  public CatalogPricingRule totalPriceMoney(Money totalPriceMoney) {
    this.totalPriceMoney = totalPriceMoney;
    return this;
  }

   /**
   * The total amount of money to charge for all matched items.  Only one of `total_price_money`, `item_price`, or `discount` can be supplied.
   * @return totalPriceMoney
  **/
  @ApiModelProperty(value = "The total amount of money to charge for all matched items.  Only one of `total_price_money`, `item_price`, or `discount` can be supplied.")
  public Money getTotalPriceMoney() {
    return totalPriceMoney;
  }

  public void setTotalPriceMoney(Money totalPriceMoney) {
    this.totalPriceMoney = totalPriceMoney;
  }

  public CatalogPricingRule itemPriceMoney(Money itemPriceMoney) {
    this.itemPriceMoney = itemPriceMoney;
    return this;
  }

   /**
   * The amount of money to charge for each matched item.  Only one of `total_price_money`, `item_price`, or `discount` can be supplied.
   * @return itemPriceMoney
  **/
  @ApiModelProperty(value = "The amount of money to charge for each matched item.  Only one of `total_price_money`, `item_price`, or `discount` can be supplied.")
  public Money getItemPriceMoney() {
    return itemPriceMoney;
  }

  public void setItemPriceMoney(Money itemPriceMoney) {
    this.itemPriceMoney = itemPriceMoney;
  }

  public CatalogPricingRule discountId(String discountId) {
    this.discountId = discountId;
    return this;
  }

   /**
   * Unique ID for the [CatalogDiscount](#type-catalogdiscount) to take off the price of all matched items.  Only one of `total_price_money`, `item_price`, or `discount` can be supplied.
   * @return discountId
  **/
  @ApiModelProperty(value = "Unique ID for the [CatalogDiscount](#type-catalogdiscount) to take off the price of all matched items.  Only one of `total_price_money`, `item_price`, or `discount` can be supplied.")
  public String getDiscountId() {
    return discountId;
  }

  public void setDiscountId(String discountId) {
    this.discountId = discountId;
  }

  public CatalogPricingRule matchProductsId(String matchProductsId) {
    this.matchProductsId = matchProductsId;
    return this;
  }

   /**
   * Unique ID for the [CatalogProductSet](#type-catalogproductset) that will be matched by this rule. A match rule matches within the entire cart.
   * @return matchProductsId
  **/
  @ApiModelProperty(value = "Unique ID for the [CatalogProductSet](#type-catalogproductset) that will be matched by this rule. A match rule matches within the entire cart.")
  public String getMatchProductsId() {
    return matchProductsId;
  }

  public void setMatchProductsId(String matchProductsId) {
    this.matchProductsId = matchProductsId;
  }

  public CatalogPricingRule applyProductsId(String applyProductsId) {
    this.applyProductsId = applyProductsId;
    return this;
  }

   /**
   * The [CatalogProductSet](#type-catalogproductset) to apply the pricing rule to within the set of matched products specified by `match_products_id`. An apply rule can only match once within the set of matched products. If left unset, the pricing rule will be applied to all products within the set of matched products.
   * @return applyProductsId
  **/
  @ApiModelProperty(value = "The [CatalogProductSet](#type-catalogproductset) to apply the pricing rule to within the set of matched products specified by `match_products_id`. An apply rule can only match once within the set of matched products. If left unset, the pricing rule will be applied to all products within the set of matched products.")
  public String getApplyProductsId() {
    return applyProductsId;
  }

  public void setApplyProductsId(String applyProductsId) {
    this.applyProductsId = applyProductsId;
  }

  public CatalogPricingRule stackable(StackableEnum stackable) {
    this.stackable = stackable;
    return this;
  }

   /**
   * Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values
   * @return stackable
  **/
  @ApiModelProperty(value = "Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values")
  public StackableEnum getStackable() {
    return stackable;
  }

  public void setStackable(StackableEnum stackable) {
    this.stackable = stackable;
  }

  public CatalogPricingRule excludeProductsId(String excludeProductsId) {
    this.excludeProductsId = excludeProductsId;
    return this;
  }

   /**
   * Identifies the [CatalogProductSet](#type-catalogproductset) to exclude from this pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.
   * @return excludeProductsId
  **/
  @ApiModelProperty(value = "Identifies the [CatalogProductSet](#type-catalogproductset) to exclude from this pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.")
  public String getExcludeProductsId() {
    return excludeProductsId;
  }

  public void setExcludeProductsId(String excludeProductsId) {
    this.excludeProductsId = excludeProductsId;
  }

  public CatalogPricingRule validFromDate(String validFromDate) {
    this.validFromDate = validFromDate;
    return this;
  }

   /**
   * Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).
   * @return validFromDate
  **/
  @ApiModelProperty(value = "Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).")
  public String getValidFromDate() {
    return validFromDate;
  }

  public void setValidFromDate(String validFromDate) {
    this.validFromDate = validFromDate;
  }

  public CatalogPricingRule validFromLocalTime(String validFromLocalTime) {
    this.validFromLocalTime = validFromLocalTime;
    return this;
  }

   /**
   * Represents the local time the pricing rule should be valid from. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
   * @return validFromLocalTime
  **/
  @ApiModelProperty(value = "Represents the local time the pricing rule should be valid from. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.")
  public String getValidFromLocalTime() {
    return validFromLocalTime;
  }

  public void setValidFromLocalTime(String validFromLocalTime) {
    this.validFromLocalTime = validFromLocalTime;
  }

  public CatalogPricingRule validUntilDate(String validUntilDate) {
    this.validUntilDate = validUntilDate;
    return this;
  }

   /**
   * Represents the date the pricing rule will become inactive.  Represented in RFC3339 full-date format (YYYY-MM-DD).
   * @return validUntilDate
  **/
  @ApiModelProperty(value = "Represents the date the pricing rule will become inactive.  Represented in RFC3339 full-date format (YYYY-MM-DD).")
  public String getValidUntilDate() {
    return validUntilDate;
  }

  public void setValidUntilDate(String validUntilDate) {
    this.validUntilDate = validUntilDate;
  }

  public CatalogPricingRule validUntilLocalTime(String validUntilLocalTime) {
    this.validUntilLocalTime = validUntilLocalTime;
    return this;
  }

   /**
   * Represents the local time at which the pricing rule will become inactive. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
   * @return validUntilLocalTime
  **/
  @ApiModelProperty(value = "Represents the local time at which the pricing rule will become inactive. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.")
  public String getValidUntilLocalTime() {
    return validUntilLocalTime;
  }

  public void setValidUntilLocalTime(String validUntilLocalTime) {
    this.validUntilLocalTime = validUntilLocalTime;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CatalogPricingRule catalogPricingRule = (CatalogPricingRule) o;
    return Objects.equals(this.name, catalogPricingRule.name) &&
        Objects.equals(this.timePeriodIds, catalogPricingRule.timePeriodIds) &&
        Objects.equals(this.totalPriceMoney, catalogPricingRule.totalPriceMoney) &&
        Objects.equals(this.itemPriceMoney, catalogPricingRule.itemPriceMoney) &&
        Objects.equals(this.discountId, catalogPricingRule.discountId) &&
        Objects.equals(this.matchProductsId, catalogPricingRule.matchProductsId) &&
        Objects.equals(this.applyProductsId, catalogPricingRule.applyProductsId) &&
        Objects.equals(this.stackable, catalogPricingRule.stackable) &&
        Objects.equals(this.excludeProductsId, catalogPricingRule.excludeProductsId) &&
        Objects.equals(this.validFromDate, catalogPricingRule.validFromDate) &&
        Objects.equals(this.validFromLocalTime, catalogPricingRule.validFromLocalTime) &&
        Objects.equals(this.validUntilDate, catalogPricingRule.validUntilDate) &&
        Objects.equals(this.validUntilLocalTime, catalogPricingRule.validUntilLocalTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, timePeriodIds, totalPriceMoney, itemPriceMoney, discountId, matchProductsId, applyProductsId, stackable, excludeProductsId, validFromDate, validFromLocalTime, validUntilDate, validUntilLocalTime);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CatalogPricingRule {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    timePeriodIds: ").append(toIndentedString(timePeriodIds)).append("\n");
    sb.append("    totalPriceMoney: ").append(toIndentedString(totalPriceMoney)).append("\n");
    sb.append("    itemPriceMoney: ").append(toIndentedString(itemPriceMoney)).append("\n");
    sb.append("    discountId: ").append(toIndentedString(discountId)).append("\n");
    sb.append("    matchProductsId: ").append(toIndentedString(matchProductsId)).append("\n");
    sb.append("    applyProductsId: ").append(toIndentedString(applyProductsId)).append("\n");
    sb.append("    stackable: ").append(toIndentedString(stackable)).append("\n");
    sb.append("    excludeProductsId: ").append(toIndentedString(excludeProductsId)).append("\n");
    sb.append("    validFromDate: ").append(toIndentedString(validFromDate)).append("\n");
    sb.append("    validFromLocalTime: ").append(toIndentedString(validFromLocalTime)).append("\n");
    sb.append("    validUntilDate: ").append(toIndentedString(validUntilDate)).append("\n");
    sb.append("    validUntilLocalTime: ").append(toIndentedString(validUntilLocalTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

